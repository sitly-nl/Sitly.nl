import UIKit

extension JobPostingForm {
    convenience init(dict: [String: Any]) throws {
        self.init(user: User(), config: Configuration())

        try DateFormatter.iso8601Formatter.date(from: dict.valueForKey("startAt")).flatMap { startDate = $0 }

        guard
            let filterData = (try dict.valueForKey("filter", ofType: String.self)).data(using: .utf8),
            let filter = try JSONSerialization.jsonObject(with: filterData, options: .allowFragments) as? [String: Any]
        else {
            return
        }
        afterSchoolDays = (try? filter.valueForKey("afterSchoolDays", ofType: [String].self).compactMap({ Day(rawValue: $0) })) ?? []
        (try? Availability(dict: filter.valueForKey("availability"))).flatMap { availability = $0 }
        needsDayCare = availability.isAvailable()
        (try? filter.valueForKey("isAvailableAfterSchool")).flatMap { hasAfterSchool = $0 }
        if let ageDict = try? filter.valueForKey("age", ofType: [String: Any].self) {
            (try? ageDict.valueForKey("min")).flatMap { fosterMinAge = $0 }
            (try? ageDict.valueForKey("max")).flatMap { fosterMaxAge = $0 }
        }
        speaksLanguages = (try? filter.valueForKey("languages", ofType: [String].self).compactMap({
            let language = Language()
            language.code = $0
            language.name = Locale.current.localizedString(forLanguageCode: $0) ?? ""
            return language
        })) ?? []
    }
}

class JobPostingForm: SearchForm {
    var startDate = Date()
    var needsDayCare = false
    var afterSchoolDays = [Day]()

    // - Due to limitations of autogenerated Decodable code for inherited classes, it is necessary to encode / decode manually (Swift 4.1.2)
    private enum CodingKeys: String, CodingKey {
        case startDate, needsDayCare, aftersSchoolDays
    }

    required init(from decoder: Decoder) throws {
        try super.init(from: decoder)
        let container = try decoder.container(keyedBy: CodingKeys.self)
        startDate = try container.decode(Date.self, forKey: .startDate)
        needsDayCare = try container.decode(Bool.self, forKey: .needsDayCare)
        afterSchoolDays = try container.decode([Day].self, forKey: .aftersSchoolDays)
    }

    override func encode(to encoder: Encoder) throws {
        try super.encode(to: encoder)
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(startDate, forKey: .startDate)
        try container.encode(needsDayCare, forKey: .needsDayCare)
        try container.encode(afterSchoolDays, forKey: .aftersSchoolDays)
    }

    override init(user: User, config: Configuration) {
        super.init(user: user, config: config)
        searchType = .jobPosting
    }
    //

    override var serverDictionaryRepresentation: [String: Any] {
        var dict = super.serverDictionaryRepresentation

        dict["startAt"] = DateFormatter.iso8601Formatter.string(from: startDate)

        if var filter = dict["filter"] as? [String: Any] {
            if hasAfterSchool {
                filter["afterSchoolDays"] = afterSchoolDays.map { $0.rawValue }
            }

            if !needsDayCare {
                dict.removeValue(forKey: "availability")
            }
            dict["filter"] = filter
        }

        return dict
    }

    override var description: String {
        var description = ""
        if occasionalCare {
            description += "Occasional babysitter".localized.lowercasingFirstLetter()
        } else {
            if availability.isAvailable() {
                description += "childcare during the day on".localized + " "
                description += availability.shortDescription
            }
            if hasAfterSchool {
                if needsDayCare {
                    description += ", "
                }
                description += "afterschool care on".localized + " "
                description += afterSchoolDays.map { $0.shortLocalized }.aggregatedDescription()
            }
        }
        description += ", " + "starting".localized + " " + DateFormatter.ddMMM.string(from: startDate)
        return description.capitalizingFirstLetter()
    }
}
